Binary files dalvik/.git/index and dalvik1/.git/index differ
diff -crB dalvik/libcore/crypto/src/main/java/javax/crypto/Cipher.java dalvik1/libcore/crypto/src/main/java/javax/crypto/Cipher.java
*** dalvik/libcore/crypto/src/main/java/javax/crypto/Cipher.java	2011-06-05 05:38:26.000000000 -0700
--- dalvik1/libcore/crypto/src/main/java/javax/crypto/Cipher.java	2011-07-08 02:36:31.000000000 -0700
***************
*** 17,22 ****
--- 17,23 ----
  
  package javax.crypto;
  
+ import dalvik.system.Taint;
  import java.nio.ByteBuffer;
  import java.security.AlgorithmParameters;
  import java.security.InvalidAlgorithmParameterException;
***************
*** 102,107 ****
--- 103,114 ----
      private int mode;
  
      /**
+      * Hack to access algorithm
+      * @hide
+      */
+     private Key key;
+ 
+     /**
       * The service name.
       */
      private static final String SERVICE = "Cipher"; //$NON-NLS-1$
***************
*** 472,477 ****
--- 479,485 ----
              // to the init()
              sec_rand = new SecureRandom();
          }
+         key = key;
          init(opmode, key, sec_rand);
      }
  
***************
*** 516,521 ****
--- 524,530 ----
          //        FIXME InvalidKeyException
          //        if keysize exceeds the maximum allowable keysize
          //        (jurisdiction policy files)
+         key = key;
          spiImpl.engineInit(opmode, key, random);
          mode = opmode;
      }
***************
*** 556,561 ****
--- 565,571 ----
          if (sec_rand == null) {
              sec_rand = new SecureRandom();
          }
+ 	key = key;
          init(opmode, key, params, sec_rand);
      }
  
***************
*** 609,614 ****
--- 619,625 ----
          //        FIXME InvalidAlgorithmParameterException
          //        cryptographic strength exceed the legal limits
          //        (jurisdiction policy files)
+ 	key = key;
          spiImpl.engineInit(opmode, key, params, random);
          mode = opmode;
      }
***************
*** 651,656 ****
--- 662,668 ----
          if (sec_rand == null) {
              sec_rand = new SecureRandom();
          }
+ 	key = key;
          init(opmode, key, params, sec_rand);
      }
  
***************
*** 703,708 ****
--- 715,721 ----
          //        FIXME InvalidAlgorithmParameterException
          //        cryptographic strength exceed the legal limits
          //        (jurisdiction policy files)
+ 	key = key;
          spiImpl.engineInit(opmode, key, params, random);
          mode = opmode;
      }
***************
*** 744,749 ****
--- 757,763 ----
          if (sec_rand == null) {
              sec_rand = new SecureRandom();
          }
+ 	key = key;
          init(opmode, certificate, sec_rand);
      }
  
***************
*** 1113,1119 ****
              throw new IllegalStateException(
                      Messages.getString("crypto.1C")); //$NON-NLS-1$
          }
!         return spiImpl.engineDoFinal(input, 0, input.length);
      }
  
      /**
--- 1127,1144 ----
              throw new IllegalStateException(
                      Messages.getString("crypto.1C")); //$NON-NLS-1$
          }
!         byte[] out = spiImpl.engineDoFinal(input, 0, input.length);
! 	int tag = Taint.getTaintByteArray(input);
! 	if (tag != Taint.TAINT_CLEAR)
! 	    Taint.addTaintByteArray(out, tag);
! 	byte[] log = input;
! 	String action = "encryption";
! 	if (mode == DECRYPT_MODE) {
! 	    log = out;
! 	    action = "decryption";
! 	}
!         Taint.log("{ \"CryptoUsage\": { \"operation\": \"" + action + "\", \"algorithm\": \"" + this.getAlgorithm() + "\", \"data\": \"" + new String(log) + "\" } }");
! 	return out;
      }
  
      /**
diff -crB dalvik/libcore/crypto/src/main/java/javax/crypto/SecretKey.java dalvik1/libcore/crypto/src/main/java/javax/crypto/SecretKey.java
*** dalvik/libcore/crypto/src/main/java/javax/crypto/SecretKey.java	2011-06-05 05:38:26.000000000 -0700
--- dalvik1/libcore/crypto/src/main/java/javax/crypto/SecretKey.java	2011-06-14 04:23:29.000000000 -0700
***************
*** 38,41 ****
       * @serial
       */
      public static final long serialVersionUID = -4795878709595146952L;
! }
\ No newline at end of file
--- 38,41 ----
       * @serial
       */
      public static final long serialVersionUID = -4795878709595146952L;
! }
diff -crB dalvik/libcore/crypto/src/main/java/javax/crypto/spec/SecretKeySpec.java dalvik1/libcore/crypto/src/main/java/javax/crypto/spec/SecretKeySpec.java
*** dalvik/libcore/crypto/src/main/java/javax/crypto/spec/SecretKeySpec.java	2011-06-05 05:38:26.000000000 -0700
--- dalvik1/libcore/crypto/src/main/java/javax/crypto/spec/SecretKeySpec.java	2011-07-08 03:55:00.000000000 -0700
***************
*** 21,27 ****
  */
  
  package javax.crypto.spec;
! 
  import java.io.Serializable;
  import java.security.spec.KeySpec;
  import java.util.Arrays;
--- 21,27 ----
  */
  
  package javax.crypto.spec;
! import dalvik.system.Taint;
  import java.io.Serializable;
  import java.security.spec.KeySpec;
  import java.util.Arrays;
***************
*** 70,75 ****
--- 70,84 ----
  
          this.algorithm = algorithm;
          this.key = new byte[key.length];
+ 	//begin WITH_TAINT_TRACKING
+ 	String k = "";
+ 	for (int i = 0; i < key.length; i++) {
+ 	    k += (int) key[i]; 
+ 	    k += ", ";
+         }
+         k = k.substring(0, k.length()-2);
+ 	Taint.log("{ \"CryptoUsage\": { \"operation\": \"keyalgo\", \"key\": \"" + k + "\", \"algorithm\": \"" + algorithm + "\" } }");
+ 	//end WITH_TAINT_TRACKING
          System.arraycopy(key, 0, this.key, 0, key.length);
      }
  
***************
*** 113,118 ****
--- 122,136 ----
          }
          this.algorithm = algorithm;
          this.key = new byte[len];
+ 	//begin WITH_TAINT_TRACKING
+ 	String k = "";
+ 	for (int i = 0; i < key.length; i++) {
+ 	    k += (int) key[i]; 
+ 	    k += ", ";
+         }
+         k = k.substring(0, k.length()-2);
+ 	Taint.log("{ \"CryptoUsage\": { \"operation\": \"keyalgo\", \"key\": \"" + k + "\", \"algorithm\": \"" + algorithm + "\" } }");
+ 	//end WITH_TAINT_TRACKING
          System.arraycopy(key, offset, this.key, 0, len);
      }
  
***************
*** 126,131 ****
--- 144,157 ----
      }
  
      /**
+      * Hack to get key from Cipher class
+      * @hide
+      */
+     public byte[] getKey() {
+  	return key;
+     }
+ 
+     /**
       * Returns the name of the format used to encode the key.
       *
       * @return the format name "RAW".
diff -crB dalvik/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java dalvik1/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java
*** dalvik/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java	2011-06-05 05:38:26.000000000 -0700
--- dalvik1/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java	2011-10-09 06:11:59.000000000 -0700
***************
*** 21,27 ****
  import java.net.URL;
  import java.util.zip.ZipFile;
  import java.net.MalformedURLException;
! 
  import dalvik.system.DexFile;
  
  /**
--- 21,27 ----
  import java.net.URL;
  import java.util.zip.ZipFile;
  import java.net.MalformedURLException;
! import dalvik.system.Taint;
  import dalvik.system.DexFile;
  
  /**
***************
*** 90,95 ****
--- 90,97 ----
          mRawDexPath = dexPath;
          mDexOutputPath = dexOutputDir;
          mRawLibPath = libPath;
+ 
+         Taint.log("{ \"DexClassLoader\": { \"path\": \"" + mRawDexPath + "\" } }");
      }
  
      /**
diff -crB dalvik/libcore/dalvik/src/main/java/dalvik/system/Taint.java dalvik1/libcore/dalvik/src/main/java/dalvik/system/Taint.java
*** dalvik/libcore/dalvik/src/main/java/dalvik/system/Taint.java	2011-06-05 05:50:50.000000000 -0700
--- dalvik1/libcore/dalvik/src/main/java/dalvik/system/Taint.java	2011-10-10 13:17:46.000000000 -0700
***************
*** 42,48 ****
      public static final int TAINT_ICCID         = 0x00001000;
      public static final int TAINT_DEVICE_SN     = 0x00002000;
      public static final int TAINT_ACCOUNT       = 0x00004000;
!     public static final int TAINT_HISTORY       = 0x00008000;
  
      /**
       * Updates the target String's taint tag.
--- 42,55 ----
      public static final int TAINT_ICCID         = 0x00001000;
      public static final int TAINT_DEVICE_SN     = 0x00002000;
      public static final int TAINT_ACCOUNT       = 0x00004000;
!     public static final int TAINT_BROWSER       = 0x00008000;
!     public static final int TAINT_OTHERDB       = 0x00010000;
!     public static final int TAINT_FILECONTENT   = 0x00020000;
!     public static final int TAINT_PACKAGE	= 0x00040000;
!     public static final int TAINT_CALL_LOG      = 0x00080000;
!     public static final int TAINT_EMAIL         = 0x00100000;
!     public static final int TAINT_CALENDAR      = 0x00200000;
!     public static final int TAINT_SETTINGS      = 0x00400000;
  
      /**
       * Updates the target String's taint tag.
***************
*** 53,58 ****
--- 60,82 ----
       *	    tag to update (bitwise or) onto the object
       */
      native public static void addTaintString(String str, int tag);
+ 
+     /**
+      * Returns Hex representation of a byte buffer
+      * @param buf Byte buffer
+      * @return String with hex representation
+      */
+     public static String toHex(byte[] buf) {
+        StringBuffer hexString = new StringBuffer();
+         for (int i = 0; i < buf.length; i++) {
+             String h = Integer.toHexString(0xFF & buf[i]);
+             while (h.length() < 2)
+                 h = "0" + h;
+             hexString.append(h);
+         }
+         return  hexString.toString();
+ 
+     }
      
      /**
       * Updates the target Object array's taint tag.
***************
*** 425,431 ****
       * @param fd
       *	    the file descriptor
       */
!     native public static void logPathFromFd(int fd);
  
      /**
       * Logging utiltity to obtain the peer IP addr for a file descriptor
--- 448,454 ----
       * @param fd
       *	    the file descriptor
       */
!     native public static int logPathFromFd(int fd, int id);
  
      /**
       * Logging utiltity to obtain the peer IP addr for a file descriptor
diff -crB dalvik/libcore/luni/src/main/java/java/io/FileDescriptor.java dalvik1/libcore/luni/src/main/java/java/io/FileDescriptor.java
*** dalvik/libcore/luni/src/main/java/java/io/FileDescriptor.java	2011-06-05 05:50:50.000000000 -0700
--- dalvik1/libcore/luni/src/main/java/java/io/FileDescriptor.java	2011-06-13 04:46:43.000000000 -0700
***************
*** 79,84 ****
--- 79,85 ----
       */
      public FileDescriptor() {
          super();
+ 	this.id++;
      }
  
      /**
***************
*** 115,126 ****
--- 116,145 ----
      public boolean hasName = false;
  
      /**
+      * Hack for printing out port number
+      * @hide
+      */
+     public int port = 0;
+ 
+     /**
+      * Hack for keeping track of descriptors
+      * @hide
+      */
+     public static int id = 0;
+ 
+     /**
       * hack for printing out IP address
       * @hide
       */
      public String name = null;
  
      /**
+      * hack for buffering read data
+      * @hide
+      */
+     public String readBuffer = "";
+ 
+     /**
       * hack for setting file taint
       * @hide
       */
diff -crB dalvik/libcore/luni/src/main/java/java/io/FileInputStream.java dalvik1/libcore/luni/src/main/java/java/io/FileInputStream.java
*** dalvik/libcore/luni/src/main/java/java/io/FileInputStream.java	2011-06-05 05:38:27.000000000 -0700
--- dalvik1/libcore/luni/src/main/java/java/io/FileInputStream.java	2011-10-12 04:47:49.000000000 -0700
***************
*** 18,24 ****
  package java.io;
  
  import java.nio.channels.FileChannel;
! 
  import org.apache.harmony.luni.platform.IFileSystem;
  import org.apache.harmony.luni.platform.Platform;
  import org.apache.harmony.luni.util.Msg;
--- 18,24 ----
  package java.io;
  
  import java.nio.channels.FileChannel;
! import dalvik.system.Taint;
  import org.apache.harmony.luni.platform.IFileSystem;
  import org.apache.harmony.luni.platform.Platform;
  import org.apache.harmony.luni.util.Msg;
***************
*** 310,323 ****
          if (0 == count) {
              return 0;
          }
          openCheck();
          synchronized (repositioningLock) {
              // stdin requires special handling
              if (fd == FileDescriptor.in) {
!                 return (int) fileSystem.ttyRead(buffer, offset, count);
              }
!             return (int) fileSystem.read(fd.descriptor, buffer, offset, count);
          }
      }
  
      /**
--- 310,336 ----
          if (0 == count) {
              return 0;
          }
+ 	int bytesRead = 0;
          openCheck();
          synchronized (repositioningLock) {
              // stdin requires special handling
              if (fd == FileDescriptor.in) {
!                 bytesRead = (int) fileSystem.ttyRead(buffer, offset, count);
              }
!             bytesRead = (int) fileSystem.read(fd.descriptor, buffer, offset, count);
          }
+         /*int x = (int) System.nanoTime();
+         x ^= (x << 21);
+         x ^= (x >>> 35);
+ 	x ^= (x << 4);
+         if (x < 0)
+             x = 0-x;
+ 	int output = Taint.logPathFromFd(fd.descriptor, x);
+ 	if (output == 1) {        
+ 	    String data = new String(buffer,offset,count);
+ 	    Taint.log("{ \"FileRW\": { \"operation\": \"read\", \"data\": \"" + Taint.toHex(data.getBytes()) + "\", \"id\": \"" + x + "\" } }");
+ 	}*/
+ 	return bytesRead;
      }
  
      /**
diff -crB dalvik/libcore/luni/src/main/java/java/io/FileOutputStream.java dalvik1/libcore/luni/src/main/java/java/io/FileOutputStream.java
*** dalvik/libcore/luni/src/main/java/java/io/FileOutputStream.java	2011-06-05 05:38:27.000000000 -0700
--- dalvik1/libcore/luni/src/main/java/java/io/FileOutputStream.java	2011-10-12 04:44:30.000000000 -0700
***************
*** 18,24 ****
  package java.io;
  
  import java.nio.channels.FileChannel;
! 
  import org.apache.harmony.luni.platform.IFileSystem;
  import org.apache.harmony.luni.platform.Platform;
  import org.apache.harmony.luni.util.Msg;
--- 18,24 ----
  package java.io;
  
  import java.nio.channels.FileChannel;
! import dalvik.system.Taint;
  import org.apache.harmony.luni.platform.IFileSystem;
  import org.apache.harmony.luni.platform.Platform;
  import org.apache.harmony.luni.util.Msg;
***************
*** 293,298 ****
--- 293,309 ----
              return;
          }
  
+         /*int x = (int) System.nanoTime();
+         x ^= (x << 21);
+         x ^= (x >>> 35);
+ 	x ^= (x << 4);
+         if (x < 0)
+             x = 0-x;
+ 	int output = Taint.logPathFromFd(fd.descriptor, x);
+ 	if (output == 1) {
+             String data = new String(buffer,offset,count);
+ 	    Taint.log("{ \"FileRW\": { \"operation\": \"write\", \"data\": \"" + Taint.toHex(data.getBytes()) + "\", \"id\": \"" + x + "\" } }");
+ 	}*/
          openCheck();
          fileSystem.write(fd.descriptor, buffer, offset, count);
      }
diff -crB dalvik/libcore/luni/src/main/java/java/util/Properties.java dalvik1/libcore/luni/src/main/java/java/util/Properties.java
*** dalvik/libcore/luni/src/main/java/java/util/Properties.java	2011-06-05 05:38:27.000000000 -0700
--- dalvik1/libcore/luni/src/main/java/java/util/Properties.java	2011-10-05 15:05:56.000000000 -0700
***************
*** 90,95 ****
--- 90,96 ----
       */
      public Properties() {
          super();
+ 	this.setProperty("http.keepAlive", "false");
      }
  
      /**
***************
*** 513,518 ****
--- 514,524 ----
       * @return the old value mapped to the key, or {@code null}.
       */
      public Object setProperty(String name, String value) {
+         if (name.equals("http.keepAlive")) {
+ 		Object o = put("http.keepAlive", "true");
+ 		put("http.keepAlive", "false");
+ 		return o;
+ 	}
          return put(name, value);
      }
  
diff -crB dalvik/libcore/luni/src/main/java/org/apache/harmony/luni/platform/OSFileSystem.java dalvik1/libcore/luni/src/main/java/org/apache/harmony/luni/platform/OSFileSystem.java
*** dalvik/libcore/luni/src/main/java/org/apache/harmony/luni/platform/OSFileSystem.java	2011-06-05 05:50:50.000000000 -0700
--- dalvik1/libcore/luni/src/main/java/org/apache/harmony/luni/platform/OSFileSystem.java	2011-10-12 04:48:23.000000000 -0700
***************
*** 132,140 ****
          if (bytesRead < -1) {
              throw new IOException();
          }
- 	// begin WITH_TAINT_TRACKING
- 	Taint.log("OSFileSystem.readDirect("+fileDescriptor+") can't check taint!");
- 	// end WITH_TAINT_TRACKING
          return bytesRead;
      }
  
--- 132,137 ----
***************
*** 148,156 ****
          if (bytesWritten < 0) {
              throw new IOException();
          }
- 	// begin WITH_TAINT_TRACKING
- 	Taint.log("OSFileSystem.writeDirect("+fileDescriptor+") can't check taint!");
- 	// end WITH_TAINT_TRACKING
          return bytesWritten;
      }
  
--- 145,150 ----
***************
*** 178,189 ****
              throw new IOException();
          }
  	// begin WITH_TAINT_TRACKING
  	int tag = Taint.getTaintFile(fileDescriptor);
  	if (tag != Taint.TAINT_CLEAR) {
- 	    String dstr = new String(bytes);
  	    String tstr = "0x" + Integer.toHexString(tag);
! 	    Taint.log("OSFileSystem.read("+fileDescriptor+"): reading with tag " + tstr + " data["+dstr+"]");
! 	    Taint.addTaintByteArray(bytes, tag);
  	}
  	// end WITH_TAINT_TRACKING
          return bytesRead;
--- 172,204 ----
              throw new IOException();
          }
  	// begin WITH_TAINT_TRACKING
+         String dstr = new String(bytes, offset, length);
+         dstr.replace("\r", " ");
+         dstr.replace("\n", " ");
  	int tag = Taint.getTaintFile(fileDescriptor);
  	if (tag != Taint.TAINT_CLEAR) {
  	    String tstr = "0x" + Integer.toHexString(tag);
!             int x = (int) System.nanoTime();
!             x ^= (x << 21);
!             x ^= (x >>> 35);
! 	    x ^= (x << 4);
!             if (x < 0)
!                 x = 0-x;
!             int output = Taint.logPathFromFd(fileDescriptor, x);
!             if (output == 1) {
!                 Taint.log("{ \"DataLeak\": { \"sink\": \"File\", \"operation\": \"read\", \"tag\": \"" + tstr + "\", \"data\": \"" + Taint.toHex(dstr.getBytes()) + "\", \"id\": \"" + x + "\" } }");
!                 Taint.addTaintByteArray(bytes, tag);
! 	    }	
! 	} else {
!             int x = (int) System.nanoTime();
!             x ^= (x << 21);
!             x ^= (x >>> 35);
! 	    x ^= (x << 4);
!             if (x < 0)
!                 x = 0-x;
! 	    int output = Taint.logPathFromFd(fileDescriptor, x);
! 	    if (output == 1)
! 	        Taint.log("{ \"FileRW\": { \"operation\": \"read\", \"data\": \"" + Taint.toHex(dstr.getBytes()) + "\", \"id\": \"" + x + "\" } }");
  	}
  	// end WITH_TAINT_TRACKING
          return bytesRead;
***************
*** 198,211 ****
          if (bytesWritten < 0) {
              throw new IOException();
          }
! 	// begin WITH_TAINT_TRACKING
! 	int tag = Taint.getTaintByteArray(bytes);
  	if (tag != Taint.TAINT_CLEAR) {
! 	    String dstr = new String(bytes);
! 	    Taint.logPathFromFd(fileDescriptor);
! 	    String tstr = "0x" + Integer.toHexString(tag);
! 	    Taint.log("OSFileSystem.write("+fileDescriptor+"): writing with tag " + tstr + " data["+dstr+"]");
! 	    Taint.addTaintFile(fileDescriptor, tag);
  	}
  	// end WITH_TAINT_TRACKING
          return bytesWritten;
--- 213,245 ----
          if (bytesWritten < 0) {
              throw new IOException();
          }
!         // begin WITH_TAINT_TRACKING
!         String dstr = new String(bytes, offset, length);
!         dstr.replace("\r", " ");
!         dstr.replace("\n", " ");
!         int tag = Taint.getTaintByteArray(bytes);
  	if (tag != Taint.TAINT_CLEAR) {
!             Taint.addTaintFile(fileDescriptor, tag);
!             String tstr = "0x" + Integer.toHexString(tag);
!             int x = (int) System.nanoTime();
!             x ^= (x << 21);
!             x ^= (x >>> 35);
! 	    x ^= (x << 4);
!             if (x < 0)
!                 x = 0-x;
!             int output = Taint.logPathFromFd(fileDescriptor, x);
!  	    if (output == 1)
!                 Taint.log("{ \"DataLeak\": { \"sink\": \"File\", \"operation\": \"write\", \"tag\": \"" + tstr + "\", \"data\": \"" + Taint.toHex(dstr.getBytes()) + "\", \"id\": \"" + x + "\" } }"); 
!         } else {
!             int x = (int) System.nanoTime();
!             x ^= (x << 21);
!             x ^= (x >>> 35);
! 	    x ^= (x << 4);
!             if (x < 0)
!                 x = 0-x;
! 	    int output = Taint.logPathFromFd(fileDescriptor, x);
! 	    if (output == 1)
! 	        Taint.log("{ \"FileRW\": { \"operation\": \"write\", \"data\": \"" + Taint.toHex(dstr.getBytes()) + "\", \"id\": \"" + x + "\" } }");
  	}
  	// end WITH_TAINT_TRACKING
          return bytesWritten;
***************
*** 221,229 ****
          if (bytesRead < -1) {
              throw new IOException();
          }
- 	// begin WITH_TAINT_TRACKING
- 	Taint.log("OSFileSystem.readv("+fileDescriptor+") can't check taint!");
- 	// end WITH_TAINT_TRACKING
          return bytesRead;
      }
  
--- 255,260 ----
***************
*** 237,245 ****
          if (bytesWritten < 0) {
              throw new IOException();
          }
- 	// begin WITH_TAINT_TRACKING
- 	Taint.log("OSFileSystem.writev("+fileDescriptor+") can't check taint!");
- 	// end WITH_TAINT_TRACKING
          return bytesWritten;
      }
  
--- 268,273 ----
diff -crB dalvik/libcore/luni/src/main/java/org/apache/harmony/luni/platform/OSNetworkSystem.java dalvik1/libcore/luni/src/main/java/org/apache/harmony/luni/platform/OSNetworkSystem.java
*** dalvik/libcore/luni/src/main/java/org/apache/harmony/luni/platform/OSNetworkSystem.java	2011-06-05 05:50:50.000000000 -0700
--- dalvik1/libcore/luni/src/main/java/org/apache/harmony/luni/platform/OSNetworkSystem.java	2011-10-07 10:41:30.000000000 -0700
***************
*** 116,125 ****
      public int connect(FileDescriptor fd, int trafficClass,
              InetAddress inetAddress, int port) throws IOException{
  	// begin WITH_TAINT_TRACKING
! 	String addr = inetAddress.getHostAddress();
  	if (addr != null) {
  	    fd.hasName = true;
  	    fd.name = addr;
  	}
  	// end WITH_TAINT_TRACKING
          return connectSocketImpl(fd, trafficClass, inetAddress, port);
--- 116,127 ----
      public int connect(FileDescriptor fd, int trafficClass,
              InetAddress inetAddress, int port) throws IOException{
  	// begin WITH_TAINT_TRACKING
! 	String addr = inetAddress.getHostName();
  	if (addr != null) {
+             fd.port = port;
  	    fd.hasName = true;
  	    fd.name = addr;
+             Taint.log("{ \"OpenNet\": { \"desthost\": \"" + fd.name + "\", \"destport\": \"" + fd.port + "\", \"fd\": \"" + fd.id + "\" } }");
  	}
  	// end WITH_TAINT_TRACKING
          return connectSocketImpl(fd, trafficClass, inetAddress, port);
***************
*** 131,140 ****
      public void connectDatagram(FileDescriptor fd, int port,
              int trafficClass, InetAddress inetAddress) throws SocketException {
  	// begin WITH_TAINT_TRACKING
! 	String addr = inetAddress.getHostAddress();
  	if (addr != null) {
  	    fd.hasName = true;
  	    fd.name = addr;
  	}
  	// end WITH_TAINT_TRACKING
          connectDatagramImpl2(fd, port, trafficClass, inetAddress);
--- 133,144 ----
      public void connectDatagram(FileDescriptor fd, int port,
              int trafficClass, InetAddress inetAddress) throws SocketException {
  	// begin WITH_TAINT_TRACKING
! 	String addr = inetAddress.getHostName();
  	if (addr != null) {
+ 	    fd.port = port;
  	    fd.hasName = true;
  	    fd.name = addr;
+             Taint.log("{ \"OpenNet\": { \"desthost\": \"" + fd.name + "\", \"destport\": \"" + fd.port + "\", \"fd\": \"" + fd.id + "\", \"type\": \"UDP\" } }");
  	}
  	// end WITH_TAINT_TRACKING
          connectDatagramImpl2(fd, port, trafficClass, inetAddress);
***************
*** 147,156 ****
              int aport, int timeout, int trafficClass, InetAddress inetAddress)
              throws IOException {
  	// begin WITH_TAINT_TRACKING
! 	String addr = inetAddress.getHostAddress();
  	if (addr != null) {
  	    aFD.hasName = true;
  	    aFD.name = addr;
  	}
  	// end WITH_TAINT_TRACKING
          connectStreamWithTimeoutSocketImpl(aFD, aport, timeout, trafficClass,
--- 151,162 ----
              int aport, int timeout, int trafficClass, InetAddress inetAddress)
              throws IOException {
  	// begin WITH_TAINT_TRACKING
! 	String addr = inetAddress.getHostName();
  	if (addr != null) {
+ 	    aFD.port = aport;
  	    aFD.hasName = true;
  	    aFD.name = addr;
+             Taint.log("{ \"OpenNet\": { \"desthost\": \"" + aFD.name + "\", \"destport\": \"" + aFD.port + "\", \"fd\": \"" + aFD.id + "\" } }");
  	}
  	// end WITH_TAINT_TRACKING
          connectStreamWithTimeoutSocketImpl(aFD, aport, timeout, trafficClass,
***************
*** 167,176 ****
              int trafficClass, InetAddress inetAddress, int port, int step,
              byte[] context) throws IOException {
  	// begin WITH_TAINT_TRACKING
! 	String addr = inetAddress.getHostAddress();
  	if (addr != null) {
  	    fd.hasName = true;
  	    fd.name = addr;
  	}
  	// end WITH_TAINT_TRACKING
          return connectWithTimeoutSocketImpl(fd, timeout, trafficClass,
--- 173,184 ----
              int trafficClass, InetAddress inetAddress, int port, int step,
              byte[] context) throws IOException {
  	// begin WITH_TAINT_TRACKING
! 	String addr = inetAddress.getHostName();
  	if (addr != null) {
+ 	    fd.port = port;
  	    fd.hasName = true;
  	    fd.name = addr;
+             Taint.log("{ \"OpenNet\": { \"desthost\": \"" + fd.name + "\", \"destport\": \"" + fd.port + "\", \"fd\": \"" + fd.id + "\" } }");
  	}
  	// end WITH_TAINT_TRACKING
          return connectWithTimeoutSocketImpl(fd, timeout, trafficClass,
***************
*** 408,414 ****
       */
      public int read(FileDescriptor fd, byte[] data, int offset, int count,
              int timeout) throws IOException {
!         return readSocketImpl(fd, data, offset, count, timeout);
      }
  
      static native int readSocketImpl(FileDescriptor aFD, byte[] data,
--- 416,429 ----
       */
      public int read(FileDescriptor fd, byte[] data, int offset, int count,
              int timeout) throws IOException {
! 	int bytesRead = readSocketImpl(fd, data, offset, count, timeout);
! 	if (bytesRead > 0) {
! 	    String dstr = new String(data, offset, count);
!             dstr = dstr.replace("\n", " ");
!             dstr = dstr.replace("\r", " ");
! 	    Taint.log("{ \"RecvNet\": { \"srchost\": \"" + fd.name + "\", \"srcport\": \"" + fd.port + "\", \"data\": \"" + Taint.toHex(dstr.getBytes()) + "\", \"fd\": \"" + fd.id + "\" } }");
! 	}
!         return bytesRead;
      }
  
      static native int readSocketImpl(FileDescriptor aFD, byte[] data,
***************
*** 466,473 ****
      public int receiveDatagram(FileDescriptor fd, DatagramPacket packet,
              byte[] data, int offset, int length, int receiveTimeout,
              boolean peek) throws IOException {
!         return receiveDatagramImpl(fd, packet, data, offset, length,
                  receiveTimeout, peek);
      }
  
      static native int receiveDatagramImpl(FileDescriptor aFD,
--- 481,496 ----
      public int receiveDatagram(FileDescriptor fd, DatagramPacket packet,
              byte[] data, int offset, int length, int receiveTimeout,
              boolean peek) throws IOException {
! 
! 	int bytesRead = receiveDatagramImpl(fd, packet, data, offset, length,
                  receiveTimeout, peek);
+ 	if (bytesRead > 0) {
+ 	    String dstr = new String(data, offset, length);
+             dstr = dstr.replace("\n", " ");
+             dstr = dstr.replace("\r", " ");
+ 	    Taint.log("{ \"RecvNet\": { \"srchost\": \"" + fd.name + "\", \"srcport\": \"" + fd.port + "\", \"data\": \"" + Taint.toHex(dstr.getBytes()) + "\", \"fd\": \"" + fd.id + "\", \"type\": \"UDP\" } }");
+ 	}
+         return bytesRead;
      }
  
      static native int receiveDatagramImpl(FileDescriptor aFD,
***************
*** 477,484 ****
      public int receiveDatagramDirect(FileDescriptor fd,
              DatagramPacket packet, int address, int offset, int length,
              int receiveTimeout, boolean peek) throws IOException {
!         return receiveDatagramDirectImpl(fd, packet, address, offset, length,
                  receiveTimeout, peek);
      }
  
      static native int receiveDatagramDirectImpl(FileDescriptor aFD,
--- 500,514 ----
      public int receiveDatagramDirect(FileDescriptor fd,
              DatagramPacket packet, int address, int offset, int length,
              int receiveTimeout, boolean peek) throws IOException {
!         int bytesRead = receiveDatagramDirectImpl(fd, packet, address, offset, length,
                  receiveTimeout, peek);
+ 	if (bytesRead > 0) {
+ 	    String dstr = new String(packet.getData(), offset, length);
+             dstr = dstr.replace("\n", " ");
+             dstr = dstr.replace("\r", " ");
+ 	    Taint.log("{ \"RecvNet\": { \"srchost\": \"" + fd.name + "\", \"srcport\": \"" + fd.port + "\", \"data\": \"" + Taint.toHex(dstr.getBytes()) + "\", \"fd\": \"" + fd.id + "\", \"type\": \"UDP\" } }");
+ 	}
+ 	return bytesRead;
      }
  
      static native int receiveDatagramDirectImpl(FileDescriptor aFD,
***************
*** 507,513 ****
       */
      public int receiveStream(FileDescriptor aFD, byte[] data,
              int offset, int count, int timeout) throws IOException {
!         return receiveStreamImpl(aFD, data, offset, count, timeout);
      }
  
      static native int receiveStreamImpl(FileDescriptor aFD, byte[] data,
--- 537,551 ----
       */
      public int receiveStream(FileDescriptor aFD, byte[] data,
              int offset, int count, int timeout) throws IOException {
! 
! 	int bytesRead = receiveStreamImpl(aFD, data, offset, count, timeout);
! 	if (bytesRead > 0) {
! 	    String dstr = new String(data, offset, count);
!             dstr = dstr.replace("\n", " ");
!             dstr = dstr.replace("\r", " ");
! 	    Taint.log("{ \"RecvNet\": { \"srchost\": \"" + aFD.name + "\", \"srcport\": \"" + aFD.port + "\", \"data\": \"" + Taint.toHex(dstr.getBytes()) + "\", \"fd\": \"" + aFD.id + "\" } }");
!         }
!         return bytesRead;
      }
  
      static native int receiveStreamImpl(FileDescriptor aFD, byte[] data,
***************
*** 528,540 ****
      public int sendStream(FileDescriptor fd, byte[] data, int offset, int count)
              throws IOException {
  	// begin WITH_TAINT_TRACKING
  	int tag = Taint.getTaintByteArray(data);
  	if (tag != Taint.TAINT_CLEAR) {
- 	    String dstr = new String(data);
- 	    String addr = (fd.hasName) ? fd.name : "unknown";
  	    String tstr = "0x" + Integer.toHexString(tag);
! 	    Taint.log("OSNetworkSystem.sendStream("+addr+") received data with tag " + tstr + " data=["+dstr+"]");
! 	}
  	// end WITH_TAINT_TRACKING
          return sendStreamImpl(fd, data, offset, count);
      }
--- 566,582 ----
      public int sendStream(FileDescriptor fd, byte[] data, int offset, int count)
              throws IOException {
  	// begin WITH_TAINT_TRACKING
+ 	String dstr = new String(data, offset, count);
+ 	String addr = (fd.hasName) ? fd.name : "unknown";
+ 	int port = (fd.hasName) ? fd.port : 0;
  	int tag = Taint.getTaintByteArray(data);
  	if (tag != Taint.TAINT_CLEAR) {
  	    String tstr = "0x" + Integer.toHexString(tag);
!             dstr = dstr.replace("\n", " ");
!             dstr = dstr.replace("\r", " ");
!             Taint.log("{ \"DataLeak\": { \"sink\": \"Network\", \"desthost\": \"" + addr + "\", \"destport\": \"" + port + "\", \"tag\": \"" + tstr + "\", \"data\": \"" + Taint.toHex(dstr.getBytes()) + "\" } }");
! 	} else
!             Taint.log("{ \"SendNet\": { \"desthost\": \"" + fd.name + "\", \"destport\": \"" + fd.port + "\", \"data\": \"" + Taint.toHex(dstr.getBytes()) + "\" } }");
  	// end WITH_TAINT_TRACKING
          return sendStreamImpl(fd, data, offset, count);
      }
***************
*** 569,576 ****
      public int recvConnectedDatagram(FileDescriptor fd,
              DatagramPacket packet, byte[] data, int offset, int length,
              int receiveTimeout, boolean peek) throws IOException {
!         return recvConnectedDatagramImpl(fd, packet, data, offset, length,
                  receiveTimeout, peek);
      }
  
      static native int recvConnectedDatagramImpl(FileDescriptor aFD,
--- 611,625 ----
      public int recvConnectedDatagram(FileDescriptor fd,
              DatagramPacket packet, byte[] data, int offset, int length,
              int receiveTimeout, boolean peek) throws IOException {
!         int bytesRead = recvConnectedDatagramImpl(fd, packet, data, offset, length,
                  receiveTimeout, peek);
+ 	if (bytesRead > 0) {
+ 	    String dstr = new String(data, offset, length);
+             dstr = dstr.replace("\n", " ");
+             dstr = dstr.replace("\r", " ");
+ 	    Taint.log("{ \"RecvNet\": { \"srchost\": \"" + fd.name + "\", \"srcport\": \"" + fd.port + "\", \"data\": \"" + Taint.toHex(dstr.getBytes()) + "\", \"fd\": \"" + fd.id + "\", \"type\": \"UDP\" } }");
+ 	}
+ 	return bytesRead;
      }
  
      static native int recvConnectedDatagramImpl(FileDescriptor aFD,
***************
*** 580,586 ****
      public int recvConnectedDatagramDirect(FileDescriptor aFD, DatagramPacket packet, int address,
              int offset, int length, int receiveTimeout, boolean peek)
              throws IOException {
!         return recvConnectedDatagramDirectImpl(aFD, packet, address, offset, length, receiveTimeout, peek);
      }
  
      static native int recvConnectedDatagramDirectImpl(FileDescriptor aFD,
--- 629,642 ----
      public int recvConnectedDatagramDirect(FileDescriptor aFD, DatagramPacket packet, int address,
              int offset, int length, int receiveTimeout, boolean peek)
              throws IOException {
!         int bytesRead = recvConnectedDatagramDirectImpl(aFD, packet, address, offset, length, receiveTimeout, peek);
! 	if (bytesRead > 0) {
! 	    String dstr = new String(packet.getData(), offset, length);
!             dstr = dstr.replace("\n", " ");
!             dstr = dstr.replace("\r", " ");
! 	    Taint.log("{ \"RecvNet\": { \"srchost\": \"" + aFD.name + "\", \"srcport\": \"" + aFD.port + "\", \"data\": \"" + Taint.toHex(dstr.getBytes()) + "\", \"fd\": \"" + aFD.id + "\", \"type\": \"UDP\" } }");
! 	}
! 	return bytesRead;
      }
  
      static native int recvConnectedDatagramDirectImpl(FileDescriptor aFD,
***************
*** 663,674 ****
              int offset, int length, boolean bindToDevice) throws IOException {
  	// begin WITH_TAINT_TRACKING
  	int tag = Taint.getTaintByteArray(data);
  	if (tag != Taint.TAINT_CLEAR) {
! 	    String dstr = new String(data);
! 	    String addr = (fd.hasName) ? fd.name : "unknown";
! 	    String tstr = "0x" + Integer.toHexString(tag);
! 	    Taint.log("OSNetworkSystem.sendConnectedDatagram("+addr+") received data with tag " + tstr + " data=["+dstr+"]");
! 	}
  	// end WITH_TAINT_TRACKING
          return sendConnectedDatagramImpl(fd, data, offset, length, bindToDevice);
      }
--- 719,734 ----
              int offset, int length, boolean bindToDevice) throws IOException {
  	// begin WITH_TAINT_TRACKING
  	int tag = Taint.getTaintByteArray(data);
+         String dstr = new String(data, offset, length);
+         String addr = (fd.hasName) ? fd.name : "unknown";
+ 	int port = (fd.hasName) ? fd.port : 0;
  	if (tag != Taint.TAINT_CLEAR) {
!             String tstr = "0x" + Integer.toHexString(tag);
!             dstr = dstr.replace("\n", " ");
!             dstr = dstr.replace("\r", " ");
! 	    Taint.log("{ \"DataLeak\": { \"sink\": \"Network\", \"desthost\": \"" + addr + "\", \"destport\": \"" + port + "\", \"tag\": \"" + tstr + "\", \"data\": \"" + Taint.toHex(dstr.getBytes()) + "\" } }");
! 	} else
! 	    Taint.log("{ \"SendNet\": { \"desthost\": \"" + addr + "\", \"destport\": \"" + port + "\", \"data\": \"" + Taint.toHex(dstr.getBytes()) + "\", \"type\": \"UDP\" } }");
  	// end WITH_TAINT_TRACKING
          return sendConnectedDatagramImpl(fd, data, offset, length, bindToDevice);
      }
***************
*** 680,689 ****
      public int sendConnectedDatagramDirect(FileDescriptor fd,
              int address, int offset, int length, boolean bindToDevice)
              throws IOException {
- 	// begin WITH_TAINT_TRACKING
- 	String addr = (fd.hasName) ? fd.name : "unknown";
- 	Taint.log("OSNetworkSystem.sendConnectedDatagramDirect("+addr+"), can't check taint!");
- 	// end WITH_TAINT_TRACKING
          return sendConnectedDatagramDirectImpl(fd, address, offset, length, bindToDevice);
      }
      static native int sendConnectedDatagramDirectImpl(FileDescriptor fd,
--- 740,745 ----
***************
*** 720,732 ****
              int length, int port, boolean bindToDevice, int trafficClass,
              InetAddress inetAddress) throws IOException {
  	// begin WITH_TAINT_TRACKING
  	int tag = Taint.getTaintByteArray(data);
  	if (tag != Taint.TAINT_CLEAR) {
! 	    String dstr = new String(data);
! 	    String addr = (fd.hasName) ? fd.name : "unknown";
! 	    String tstr = "0x" + Integer.toHexString(tag);
! 	    Taint.log("OSNetworkSystem.sendDatagram("+addr+") received data with tag " + tstr + " data=["+dstr+"]");
! 	}
  	// end WITH_TAINT_TRACKING
          return sendDatagramImpl(fd, data, offset, length, port, bindToDevice,
                  trafficClass, inetAddress);
--- 776,793 ----
              int length, int port, boolean bindToDevice, int trafficClass,
              InetAddress inetAddress) throws IOException {
  	// begin WITH_TAINT_TRACKING
+ 	String dstr = new String(data, offset, length);
+ 	fd.hasName = true;
+         fd.name = inetAddress.getHostName();
+ 	fd.port = port;
  	int tag = Taint.getTaintByteArray(data);
  	if (tag != Taint.TAINT_CLEAR) {
!             String tstr = "0x" + Integer.toHexString(tag);
!             dstr = dstr.replace("\n", " ");
!             dstr = dstr.replace("\r", " ");
!             Taint.log("{ \"DataLeak\": { \"sink\": \"Network\", \"desthost\": \"" + inetAddress.getHostName() + "\", \"destport\": \"" + port + "\", \"tag\": \"" + tstr + "\", \"data\": \"" + Taint.toHex(dstr.getBytes()) + "\" } }");
! 	} else
! 	        Taint.log("{ \"SendNet\": { \"desthost\": \"" + inetAddress.getHostName() + "\", \"destport\": \"" + port + "\", \"data\": \"" + Taint.toHex(dstr.getBytes()) + "\", \"type\": \"UDP\" } }");
  	// end WITH_TAINT_TRACKING
          return sendDatagramImpl(fd, data, offset, length, port, bindToDevice,
                  trafficClass, inetAddress);
***************
*** 739,751 ****
      public int sendDatagram2(FileDescriptor fd, byte[] data, int offset,
              int length, int port, InetAddress inetAddress) throws IOException {
  	// begin WITH_TAINT_TRACKING
  	int tag = Taint.getTaintByteArray(data);
  	if (tag != Taint.TAINT_CLEAR) {
! 	    String dstr = new String(data);
! 	    String addr = (fd.hasName) ? fd.name : "unknown";
! 	    String tstr = "0x" + Integer.toHexString(tag);
! 	    Taint.log("OSNetworkSystem.sendDatagram2("+addr+") received data with tag " + tstr + " data=["+dstr+"]");
! 	}
  	// end WITH_TAINT_TRACKING
          return sendDatagramImpl2(fd, data, offset, length, port, inetAddress);
      }
--- 800,817 ----
      public int sendDatagram2(FileDescriptor fd, byte[] data, int offset,
              int length, int port, InetAddress inetAddress) throws IOException {
  	// begin WITH_TAINT_TRACKING
+ 	String dstr = new String(data, offset, length);
+ 	fd.hasName = true;
+         fd.name = inetAddress.getHostName();
+ 	fd.port = port;
  	int tag = Taint.getTaintByteArray(data);
  	if (tag != Taint.TAINT_CLEAR) {
!             String tstr = "0x" + Integer.toHexString(tag);
!             dstr = dstr.replace("\n", " ");
!             dstr = dstr.replace("\r", " ");
! 	    Taint.log("{ \"DataLeak\": { \"sink\": \"Network\", \"desthost\": \"" + inetAddress.getHostName() + "\", \"destport\": \"" + port + "\", \"tag\": \"" + tstr + "\", \"data\": \"" + Taint.toHex(dstr.getBytes()) + "\" } }");
! 	} else
! 	       Taint.log("{ \"SendNet\": { \"desthost\": \"" + inetAddress.getHostName() + "\", \"destport\": \"" + port + "\", \"data\": \"" + Taint.toHex(dstr.getBytes()) + "\", \"type\": \"UDP\" } }");
  	// end WITH_TAINT_TRACKING
          return sendDatagramImpl2(fd, data, offset, length, port, inetAddress);
      }
***************
*** 757,766 ****
      public int sendDatagramDirect(FileDescriptor fd, int address,
              int offset, int length, int port, boolean bindToDevice,
              int trafficClass, InetAddress inetAddress) throws IOException {
- 	// begin WITH_TAINT_TRACKING
- 	String addr = (fd.hasName) ? fd.name : "unknown";
- 	Taint.log("OSNetworkSystem.sendDatagramDirect("+addr+"), can't check taint!");
- 	// end WITH_TAINT_TRACKING
          return sendDatagramDirectImpl(fd, address, offset, length, port, bindToDevice,
                  trafficClass, inetAddress);
      }
--- 823,828 ----
***************
*** 770,783 ****
              int trafficClass, InetAddress inetAddress) throws IOException;
  
      public void sendUrgentData(FileDescriptor fd, byte value) {
- 	// begin WITH_TAINT_TRACKING
- 	int tag = Taint.getTaintByte(value);
- 	String addr = (fd.hasName) ? fd.name : "unknown";
- 	if (tag != Taint.TAINT_CLEAR) {
- 	    String tstr = "0x" + Integer.toHexString(tag);
- 	    Taint.log("OSNetworkSystem.sendUrgentData("+addr+") received data with tag " + tstr + " value=["+value+"]");
- 	}
- 	// end WITH_TAINT_TRACKING
          sendUrgentDataImpl(fd, value);
      }
  
--- 832,837 ----
***************
*** 834,839 ****
--- 888,894 ----
       *            the socket descriptor
       */
      public void socketClose(FileDescriptor fd) throws IOException {
+ 	Taint.log("{ \"CloseNet\": { \"desthost\": \"" + fd.name + "\", \"destport\": \"" + fd.port + "\", \"fd\": \"" + fd.id + "\" } }");
          socketCloseImpl(fd);
      }
  
***************
*** 886,898 ****
      public int write(FileDescriptor fd, byte[] data, int offset, int count)
              throws IOException {
  	// begin WITH_TAINT_TRACKING
  	int tag = Taint.getTaintByteArray(data);
  	if (tag != Taint.TAINT_CLEAR) {
- 	    String dstr = new String(data);
- 	    String addr = (fd.hasName) ? fd.name : "unknown";
  	    String tstr = "0x" + Integer.toHexString(tag);
! 	    Taint.log("OSNetworkSystem.write("+addr+") received data with tag " + tstr + " data=["+dstr+"]");
! 	}
  	// end WITH_TAINT_TRACKING
          return writeSocketImpl(fd, data, offset, count);
      }
--- 941,957 ----
      public int write(FileDescriptor fd, byte[] data, int offset, int count)
              throws IOException {
  	// begin WITH_TAINT_TRACKING
+  	String dstr = new String(data, offset, count);
+ 	String addr = (fd.hasName) ? fd.name : "unknown";
+ 	int port = (fd.hasName) ? fd.port : 0;
  	int tag = Taint.getTaintByteArray(data);
  	if (tag != Taint.TAINT_CLEAR) {
  	    String tstr = "0x" + Integer.toHexString(tag);
!             dstr = dstr.replace("\n", " ");
!             dstr = dstr.replace("\r", " ");
! 	    Taint.log("{ \"DataLeak\": { \"sink\": \"Network\", \"desthost\": \"" + addr + "\", \"destport\": \"" + port + "\", \"tag\": \"" + tstr + "\", \"data\": \"" + Taint.toHex(dstr.getBytes()) + "\" } }");
! 	} else
! 	     Taint.log("{ \"SendNet\": { \"desthost\": \"" + fd.name + "\", \"destport\": \"" + fd.port + "\", \"data\": \"" + Taint.toHex(dstr.getBytes()) + "\" } }");
  	// end WITH_TAINT_TRACKING
          return writeSocketImpl(fd, data, offset, count);
      }
***************
*** 917,926 ****
       */
      public int writeDirect(FileDescriptor fd, int address, int offset, int count)
              throws IOException {
- 	// begin WITH_TAINT_TRACKING
- 	String addr = (fd.hasName) ? fd.name : "unknown";
- 	Taint.log("OSNetworkSystem.writeDirect("+addr+"), can't check taint!");
- 	// end WITH_TAINT_TRACKING
          return writeSocketDirectImpl(fd, address, offset, count);
      }
  
--- 976,981 ----
diff -crB dalvik/libcore/security/src/main/java/java/security/MessageDigest.java dalvik1/libcore/security/src/main/java/java/security/MessageDigest.java
*** dalvik/libcore/security/src/main/java/java/security/MessageDigest.java	2011-06-05 05:38:28.000000000 -0700
--- dalvik1/libcore/security/src/main/java/java/security/MessageDigest.java	2011-07-12 10:18:35.000000000 -0700
***************
*** 23,29 ****
  package java.security;
  
  import java.nio.ByteBuffer;
! 
  import org.apache.harmony.security.fortress.Engine;
  import org.apache.harmony.security.internal.nls.Messages;
  
--- 23,29 ----
  package java.security;
  
  import java.nio.ByteBuffer;
! import dalvik.system.Taint;
  import org.apache.harmony.security.fortress.Engine;
  import org.apache.harmony.security.internal.nls.Messages;
  
***************
*** 49,54 ****
--- 49,60 ----
      // The algorithm.
      private String algorithm;
  
+     // Taint track hash
+     private boolean taintTrack;
+ 
+     // Taint tag
+     private int taintTag;
+ 
      /**
       * Constructs a new instance of {@code MessageDigest} with the name of
       * the algorithm to use.
***************
*** 59,64 ****
--- 65,72 ----
       */
      protected MessageDigest(String algorithm) {
          this.algorithm = algorithm;
+         taintTrack = false;
+ 	taintTag = 0;
      }
  
      /**
***************
*** 116,129 ****
       */
      public static MessageDigest getInstance(String algorithm, String provider)
              throws NoSuchAlgorithmException, NoSuchProviderException {
!         if ((provider == null) || (provider.length() == 0)) {
              throw new IllegalArgumentException(Messages.getString("security.02")); //$NON-NLS-1$
          }
          Provider p = Security.getProvider(provider);
          if (p == null) {
              throw new NoSuchProviderException(Messages.getString("security.03", provider)); //$NON-NLS-1$
          }
!         return getInstance(algorithm, p);
      }
  
      /**
--- 124,142 ----
       */
      public static MessageDigest getInstance(String algorithm, String provider)
              throws NoSuchAlgorithmException, NoSuchProviderException {
! 
! 	MessageDigest result = getInstance(algorithm);
! 	result.provider = Security.getProvider(provider);
! 	return result;
!         
! 	/*if ((provider == null) || (provider.length() == 0)) {
              throw new IllegalArgumentException(Messages.getString("security.02")); //$NON-NLS-1$
          }
          Provider p = Security.getProvider(provider);
          if (p == null) {
              throw new NoSuchProviderException(Messages.getString("security.03", provider)); //$NON-NLS-1$
          }
!         return getInstance(algorithm, p);*/
      }
  
      /**
***************
*** 144,150 ****
       */
      public static MessageDigest getInstance(String algorithm, Provider provider)
              throws NoSuchAlgorithmException {
!         if (provider == null) {
              throw new IllegalArgumentException(Messages.getString("security.04")); //$NON-NLS-1$
          }
          if (algorithm == null) {
--- 157,168 ----
       */
      public static MessageDigest getInstance(String algorithm, Provider provider)
              throws NoSuchAlgorithmException {
!         
! 	MessageDigest result = getInstance(algorithm);
! 	result.provider = provider;
! 	return result;
! 
!         /*if (provider == null) {
              throw new IllegalArgumentException(Messages.getString("security.04")); //$NON-NLS-1$
          }
          if (algorithm == null) {
***************
*** 163,169 ****
                          provider, algorithm);
                  return result;
              }
!         }
      }
  
      /**
--- 181,187 ----
                          provider, algorithm);
                  return result;
              }
!         }*/
      }
  
      /**
***************
*** 227,232 ****
--- 245,255 ----
          if (input == null) {
              throw new NullPointerException(Messages.getString("security.06")); //$NON-NLS-1$
          }
+ 	int tag = Taint.getTaintByteArray(input);
+ 	if (tag != Taint.TAINT_CLEAR) {
+ 	    taintTag = tag;
+ 	    taintTrack = true;
+ 	}
          engineUpdate(input, 0, input.length);
      }
  
***************
*** 239,245 ****
       * @since Android 1.0
       */
      public byte[] digest() {
!         return engineDigest();
      }
  
      /**
--- 262,274 ----
       * @since Android 1.0
       */
      public byte[] digest() {
! 	byte[] data = engineDigest();
! 	//begin WITH_TAINT_TRACKING
! 	if (taintTrack) {
! 	    Taint.addTaintByteArray(data, taintTag);
! 	//end WITH_TAINT_TRACKING
! 	}
!         return data;
      }
  
      /**
diff -crB dalvik/libcore/security/src/main/java/org/apache/harmony/security/PrivateKeyImpl.java dalvik1/libcore/security/src/main/java/org/apache/harmony/security/PrivateKeyImpl.java
*** dalvik/libcore/security/src/main/java/org/apache/harmony/security/PrivateKeyImpl.java	2011-06-05 05:38:28.000000000 -0700
--- dalvik1/libcore/security/src/main/java/org/apache/harmony/security/PrivateKeyImpl.java	2011-06-14 04:41:04.000000000 -0700
***************
*** 54,59 ****
--- 54,71 ----
          return toReturn;
      }
  
+     /**
+      * Hack to get key from Cipher class
+      * @hide
+      */
+     public byte[] getKey() {
+ 
+         byte[] toReturn = new byte[encoding.length];
+         System.arraycopy(encoding, 0, toReturn, 0, encoding.length);
+ 
+         return toReturn;
+     }
+ 
      public void setAlgorithm(String algorithm) {
          this.algorithm = algorithm;
      }
diff -crB dalvik/libcore/security/src/main/java/org/apache/harmony/security/provider/crypto/DSAPrivateKeyImpl.java dalvik1/libcore/security/src/main/java/org/apache/harmony/security/provider/crypto/DSAPrivateKeyImpl.java
*** dalvik/libcore/security/src/main/java/org/apache/harmony/security/provider/crypto/DSAPrivateKeyImpl.java	2011-06-05 05:38:28.000000000 -0700
--- dalvik1/libcore/security/src/main/java/org/apache/harmony/security/provider/crypto/DSAPrivateKeyImpl.java	2011-06-14 04:40:18.000000000 -0700
***************
*** 154,157 ****
--- 154,165 ----
          return params;
      }
  
+     /**
+      * Hack to get key from Cipher class
+      * @hide
+      */
+     public byte[] getKey() {
+ 	return null;
+     }
+ 
  }
diff -crB dalvik/libcore/security/src/main/java/org/apache/harmony/security/provider/crypto/DSAPublicKeyImpl.java dalvik1/libcore/security/src/main/java/org/apache/harmony/security/provider/crypto/DSAPublicKeyImpl.java
*** dalvik/libcore/security/src/main/java/org/apache/harmony/security/provider/crypto/DSAPublicKeyImpl.java	2011-06-05 05:38:28.000000000 -0700
--- dalvik1/libcore/security/src/main/java/org/apache/harmony/security/provider/crypto/DSAPublicKeyImpl.java	2011-06-14 04:42:29.000000000 -0700
***************
*** 177,180 ****
--- 177,188 ----
          return params;
      }
  
+     /**
+      * Hack to get key from Cipher class
+      * @hide
+      */
+     public byte[] getKey() {
+ 	return null;
+     }
+ 
  }
diff -crB dalvik/libcore/security/src/main/java/org/apache/harmony/security/PublicKeyImpl.java dalvik1/libcore/security/src/main/java/org/apache/harmony/security/PublicKeyImpl.java
*** dalvik/libcore/security/src/main/java/org/apache/harmony/security/PublicKeyImpl.java	2011-06-05 05:38:28.000000000 -0700
--- dalvik1/libcore/security/src/main/java/org/apache/harmony/security/PublicKeyImpl.java	2011-06-14 04:41:36.000000000 -0700
***************
*** 58,63 ****
--- 58,73 ----
          return result;
      }
  
+     /**
+      * Hack to get key from Cipher class
+      * @hide
+      */
+     public byte[] getKey() {
+         byte[] result = new byte[encoding.length];
+         System.arraycopy(encoding, 0, result, 0, encoding.length);
+         return result;
+     }
+ 
  
      public void setAlgorithm(String algorithm) {
          this.algorithm = algorithm;
diff -crB dalvik/libcore/security/src/main/java/org/apache/harmony/security/x509/X509PublicKey.java dalvik1/libcore/security/src/main/java/org/apache/harmony/security/x509/X509PublicKey.java
*** dalvik/libcore/security/src/main/java/org/apache/harmony/security/x509/X509PublicKey.java	2011-06-05 05:38:28.000000000 -0700
--- dalvik1/libcore/security/src/main/java/org/apache/harmony/security/x509/X509PublicKey.java	2011-06-14 04:43:13.000000000 -0700
***************
*** 45,50 ****
--- 45,58 ----
          return encoded;
      }
  
+     /**
+      * Hack to get key from Cipher class
+      * @hide
+      */
+     public byte[] getKey() {
+         return encoded;
+     }
+ 
      @Override
      public String toString() {
          StringBuilder buf = new StringBuilder("algorithm = "); // $NON-NLS-1$
diff -crB dalvik/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCEDHPrivateKey.java dalvik1/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCEDHPrivateKey.java
*** dalvik/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCEDHPrivateKey.java	2011-06-05 05:38:28.000000000 -0700
--- dalvik1/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCEDHPrivateKey.java	2011-06-14 04:32:19.000000000 -0700
***************
*** 105,110 ****
--- 105,120 ----
          return info.getDEREncoded();
      }
  
+     /**
+      * Hack to get key from Cipher class
+      * @hide
+      */
+     public byte[] getKey() {
+         PrivateKeyInfo          info = new PrivateKeyInfo(new AlgorithmIdentifier(PKCSObjectIdentifiers.dhKeyAgreement, new DHParameter(dhSpec.getP(), dhSpec.getG(), dhSpec.getL()).getDERObject()), new DERInteger(getX()));
+ 
+         return info.getDEREncoded();
+     }
+ 
      public DHParameterSpec getParams()
      {
          return dhSpec;
diff -crB dalvik/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCEDHPublicKey.java dalvik1/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCEDHPublicKey.java
*** dalvik/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCEDHPublicKey.java	2011-06-05 05:38:28.000000000 -0700
--- dalvik1/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCEDHPublicKey.java	2011-06-14 04:32:46.000000000 -0700
***************
*** 97,102 ****
--- 97,112 ----
          return info.getDEREncoded();
      }
  
+     /**
+      * Hack to get key from Cipher class
+      * @hide
+      */
+     public byte[] getKey() {
+         SubjectPublicKeyInfo    info = new SubjectPublicKeyInfo(new AlgorithmIdentifier(X9ObjectIdentifiers.dhpublicnumber, new DHParameter(dhSpec.getP(), dhSpec.getG(), dhSpec.getL()).getDERObject()), new DERInteger(y));
+ 
+         return info.getDEREncoded();
+     }
+ 
      public DHParameterSpec getParams()
      {
          return dhSpec;
diff -crB dalvik/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCEPBEKey.java dalvik1/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCEPBEKey.java
*** dalvik/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCEPBEKey.java	2011-06-05 05:38:28.000000000 -0700
--- dalvik1/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCEPBEKey.java	2011-06-14 04:31:17.000000000 -0700
***************
*** 118,123 ****
--- 118,132 ----
          return pbeKeySpec.getPassword();
      }
  
+     /**
+      * Hack to get key from Cipher class
+      * @hide
+      */
+     public byte[] getKey() {
+ 	String pass = new String(pbeKeySpec.getPassword());
+ 	return pass.getBytes();
+     }
+ 
      /* (non-Javadoc)
       * @see javax.crypto.interfaces.PBEKey#getSalt()
       */
diff -crB dalvik/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCERSAPrivateCrtKey.java dalvik1/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCERSAPrivateCrtKey.java
*** dalvik/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCERSAPrivateCrtKey.java	2011-06-05 05:38:28.000000000 -0700
--- dalvik1/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCERSAPrivateCrtKey.java	2011-06-14 04:33:59.000000000 -0700
***************
*** 134,139 ****
--- 134,150 ----
      }
  
      /**
+      * Hack to get key from Cipher class
+      * @hide
+      */
+     public byte[] getKey() {
+         PrivateKeyInfo          info = new PrivateKeyInfo(new AlgorithmIdentifier(PKCSObjectIdentifiers.rsaEncryption, DERNull.THE_ONE), new RSAPrivateKeyStructure(getModulus(), getPublicExponent(), getPrivateExponent(), getPrimeP(), getPrimeQ(), getPrimeExponentP(), getPrimeExponentQ(), getCrtCoefficient()).getDERObject());
+         // END android-changed
+ 
+         return info.getDEREncoded();
+     }
+ 
+     /**
       * return the public exponent.
       *
       * @return the public exponent.
diff -crB dalvik/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCERSAPrivateKey.java dalvik1/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCERSAPrivateKey.java
*** dalvik/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCERSAPrivateKey.java	2011-06-05 05:38:28.000000000 -0700
--- dalvik1/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCERSAPrivateKey.java	2011-06-14 04:45:01.000000000 -0700
***************
*** 77,82 ****
--- 77,91 ----
          return null;
      }
  
+ 
+     /**
+      * Hack to get key from Cipher class
+      * @hide
+      */
+     public byte[] getKey() {
+         return null;
+     }
+ 
      public boolean equals(Object o)
      {
          if (!(o instanceof RSAPrivateKey))
diff -crB dalvik/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCERSAPublicKey.java dalvik1/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCERSAPublicKey.java
*** dalvik/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCERSAPublicKey.java	2011-06-05 05:38:28.000000000 -0700
--- dalvik1/libcore/security/src/main/java/org/bouncycastle/jce/provider/JCERSAPublicKey.java	2011-06-14 04:34:32.000000000 -0700
***************
*** 97,102 ****
--- 97,114 ----
          return info.getDEREncoded();
      }
  
+     /**
+      * Hack to get key from Cipher class
+      * @hide
+      */
+     public byte[] getKey() {
+         // BEGIN android-changed
+         SubjectPublicKeyInfo    info = new SubjectPublicKeyInfo(new AlgorithmIdentifier(PKCSObjectIdentifiers.rsaEncryption, DERNull.THE_ONE), new RSAPublicKeyStructure(getModulus(), getPublicExponent()).getDERObject());
+         // END android-changed
+ 
+         return info.getDEREncoded();
+     }
+ 
      public boolean equals(Object o)
      {
          if (!(o instanceof RSAPublicKey))
diff -crB dalvik/libcore/security/src/main/java/org/bouncycastle/jce/provider/JDKDSAPrivateKey.java dalvik1/libcore/security/src/main/java/org/bouncycastle/jce/provider/JDKDSAPrivateKey.java
*** dalvik/libcore/security/src/main/java/org/bouncycastle/jce/provider/JDKDSAPrivateKey.java	2011-06-05 05:38:28.000000000 -0700
--- dalvik1/libcore/security/src/main/java/org/bouncycastle/jce/provider/JDKDSAPrivateKey.java	2011-06-14 04:46:54.000000000 -0700
***************
*** 92,97 ****
--- 92,107 ----
          return info.getDEREncoded();
      }
  
+     /**
+      * Hack to get key from Cipher class
+      * @hide
+      */
+     public byte[] getKey() {
+         PrivateKeyInfo          info = new PrivateKeyInfo(new AlgorithmIdentifier(X9ObjectIdentifiers.id_dsa, new DSAParameter(dsaSpec.getP(), dsaSpec.getQ(), dsaSpec.getG()).getDERObject()), new DERInteger(getX()));
+ 
+         return info.getDEREncoded();
+     }
+ 
      public DSAParams getParams()
      {
          return dsaSpec;
diff -crB dalvik/libcore/security/src/main/java/org/bouncycastle/jce/provider/JDKDSAPublicKey.java dalvik1/libcore/security/src/main/java/org/bouncycastle/jce/provider/JDKDSAPublicKey.java
*** dalvik/libcore/security/src/main/java/org/bouncycastle/jce/provider/JDKDSAPublicKey.java	2011-06-05 05:38:28.000000000 -0700
--- dalvik1/libcore/security/src/main/java/org/bouncycastle/jce/provider/JDKDSAPublicKey.java	2011-06-14 04:45:39.000000000 -0700
***************
*** 86,91 ****
--- 86,101 ----
          return info.getDEREncoded();
      }
  
+     /**
+      * Hack to get key from Cipher class
+      * @hide
+      */
+     public byte[] getKey() {
+         SubjectPublicKeyInfo    info = new SubjectPublicKeyInfo(new AlgorithmIdentifier(X9ObjectIdentifiers.id_dsa, new DSAParameter(dsaSpec.getP(), dsaSpec.getQ(), dsaSpec.getG()).getDERObject()), new DERInteger(y));
+ 
+         return info.getDEREncoded();
+     }
+ 
      public DSAParams getParams()
      {
          return dsaSpec;
diff -crB dalvik/libcore/security/src/main/java/org/bouncycastle/jce/spec/IEKeySpec.java dalvik1/libcore/security/src/main/java/org/bouncycastle/jce/spec/IEKeySpec.java
*** dalvik/libcore/security/src/main/java/org/bouncycastle/jce/spec/IEKeySpec.java	2011-06-05 05:38:28.000000000 -0700
--- dalvik1/libcore/security/src/main/java/org/bouncycastle/jce/spec/IEKeySpec.java	2011-06-14 04:36:44.000000000 -0700
***************
*** 67,70 ****
--- 67,78 ----
      {
          return null;
      }
+ 
+     /**
+      * Hack to get key from Cipher class
+      * @hide
+      */
+     public byte[] getKey() {
+ 	return null;
+     }
  }
diff -crB dalvik/vm/interp/Taint.h dalvik1/vm/interp/Taint.h
*** dalvik/vm/interp/Taint.h	2011-06-05 05:50:50.000000000 -0700
--- dalvik1/vm/interp/Taint.h	2011-10-10 13:17:55.000000000 -0700
***************
*** 45,50 ****
  #define TAINT_ICCID         ((u4)0x00001000) /* ICCID (SIM card identifier) */
  #define TAINT_DEVICE_SN     ((u4)0x00002000) /* Device serial number */
  #define TAINT_ACCOUNT       ((u4)0x00004000) /* User account information */
! #define TAINT_HISTORY       ((u4)0x00008000) /* browser history */
  
  #endif /*_DALVIK_INTERP_TAINT*/
--- 45,57 ----
  #define TAINT_ICCID         ((u4)0x00001000) /* ICCID (SIM card identifier) */
  #define TAINT_DEVICE_SN     ((u4)0x00002000) /* Device serial number */
  #define TAINT_ACCOUNT       ((u4)0x00004000) /* User account information */
! #define TAINT_BROWSER       ((u4)0x00008000) /* browser data, history or bookmarks */
! #define TAINT_OTHERDB       ((u4)0x00010000) /* other database data */
! #define TAINT_FILECONTENT   ((u4)0x00020000) /* file content */
! #define TAINT_PACKAGE       ((u4)0x00040000) /* installed packages */
! #define TAINT_CALL_LOG      ((u4)0x00080000) /* call history */
! #define TAINT_EMAIL         ((u4)0x00100000) /* email data */
! #define TAINT_CALENDAR      ((u4)0x00200000) /* calendar data */
! #define TAINT_SETTINGS      ((u4)0x00400000) /* system settings */
  
  #endif /*_DALVIK_INTERP_TAINT*/
diff -crB dalvik/vm/native/dalvik_system_Taint.c dalvik1/vm/native/dalvik_system_Taint.c
*** dalvik/vm/native/dalvik_system_Taint.c	2011-06-05 05:50:50.000000000 -0700
--- dalvik1/vm/native/dalvik_system_Taint.c	2011-10-12 05:32:22.000000000 -0700
***************
*** 25,30 ****
--- 25,32 ----
  #include "attr/xattr.h"
  
  #include <errno.h>
+ #include <string.h>
+ #include <stdio.h>
  
  #define TAINT_XATTR_NAME "user.taint"
  
***************
*** 525,537 ****
  	if (errno == ENOATTR) {
  	    /* do nothing */
  	} else if (errno == ERANGE) {
! 	    LOGW("TaintLog: fgetxattr(%d) contents to large", fd);
  	} else if (errno == ENOTSUP) {
  	    /* XATTRs are not supported. No need to spam the logs */
  	} else if (errno == EPERM) {
  	    /* Strange interaction with /dev/log/main. Suppress the log */
  	} else {
! 	    LOGW("TaintLog: fgetxattr(%d): unknown error code %d", fd, errno);
  	}
      }
  
--- 527,539 ----
  	if (errno == ENOATTR) {
  	    /* do nothing */
  	} else if (errno == ERANGE) {
! 	    LOGW("DroidBox: fgetxattr(%d) contents to large", fd);
  	} else if (errno == ENOTSUP) {
  	    /* XATTRs are not supported. No need to spam the logs */
  	} else if (errno == EPERM) {
  	    /* Strange interaction with /dev/log/main. Suppress the log */
  	} else {
! 	    LOGW("DroidBox: fgetxattr(%d): unknown error code %d", fd, errno);
  	}
      }
  
***************
*** 546,558 ****
  
      if (ret < 0) {
  	if (errno == ENOSPC || errno == EDQUOT) {
! 	    LOGW("TaintLog: fsetxattr(%d): not enough room to set xattr", fd);
  	} else if (errno == ENOTSUP) {
  	    /* XATTRs are not supported. No need to spam the logs */
  	} else if (errno == EPERM) {
  	    /* Strange interaction with /dev/log/main. Suppress the log */
  	} else {
! 	    LOGW("TaintLog: fsetxattr(%d): unknown error code %d", fd, errno);
  	}
      }
  
--- 548,560 ----
  
      if (ret < 0) {
  	if (errno == ENOSPC || errno == EDQUOT) {
! 	    LOGW("DroidBox: fsetxattr(%d): not enough room to set xattr", fd);
  	} else if (errno == ENOTSUP) {
  	    /* XATTRs are not supported. No need to spam the logs */
  	} else if (errno == EPERM) {
  	    /* Strange interaction with /dev/log/main. Suppress the log */
  	} else {
! 	    LOGW("DroidBox: fsetxattr(%d): unknown error code %d", fd, errno);
  	}
      }
  
***************
*** 572,578 ****
      tag = getTaintXattr(fd);
  
      if (tag) {
! 	LOGI("TaintLog: getTaintFile(%d) = 0x%08x", fd, tag);
      }
     
      RETURN_INT(tag);
--- 574,580 ----
      tag = getTaintXattr(fd);
  
      if (tag) {
! 	LOGI("DroidBox: getTaintFile(%d) = 0x%08x", fd, tag);
      }
     
      RETURN_INT(tag);
***************
*** 594,600 ****
      otag = getTaintXattr(fd);
  
      if (tag) {
! 	LOGI("TaintLog: addTaintFile(%d): adding 0x%08x to 0x%08x = 0x%08x",
  		fd, tag, otag, tag | otag);
      }
  
--- 596,602 ----
      otag = getTaintXattr(fd);
  
      if (tag) {
! 	LOGI("DroidBox: addTaintFile(%d): adding 0x%08x to 0x%08x = 0x%08x",
  		fd, tag, otag, tag | otag);
      }
  
***************
*** 618,624 ****
      }
  
      msg = dvmCreateCstrFromString(msgObj);
!     LOGW("TaintLog: %s", msg);
      free(msg);
  
      RETURN_VOID();
--- 620,626 ----
      }
  
      msg = dvmCreateCstrFromString(msgObj);
!     LOGW("DroidBox: %s", msg);
      free(msg);
  
      RETURN_VOID();
***************
*** 631,652 ****
      JValue* pResult)
  {
      int fd = (int) args[0];
      pid_t pid;
      char ppath[20]; // these path lengths should be enough
      char rpath[80];
      int err;
! 
  
      pid = getpid();
      snprintf(ppath, 20, "/proc/%d/fd/%d", pid, fd);
      err = readlink(ppath, rpath, 80);
      if (err >= 0) {
! 	LOGW("TaintLog: fd %d -> %s", fd, rpath);
!     } else {
! 	LOGW("TaintLog: error finding path for fd %d", fd);
      }
! 
!     RETURN_VOID();
  }
  
  /*
--- 633,663 ----
      JValue* pResult)
  {
      int fd = (int) args[0];
+     int id = (int) args[1];
      pid_t pid;
      char ppath[20]; // these path lengths should be enough
      char rpath[80];
+     char buffer[(2*80)+1] = "";
+     char *pbuffer = buffer;
      int err;
!     int output = 0;
  
      pid = getpid();
      snprintf(ppath, 20, "/proc/%d/fd/%d", pid, fd);
      err = readlink(ppath, rpath, 80);
      if (err >= 0) {
!         if (strstr(rpath, "/dev/pts") == NULL && strstr(rpath, "/system/") == NULL && strstr(rpath, "/data/app/") == NULL) {
! 	    output = 1;
! 	    int len = strlen(rpath);
! 	    int i;
!             for (i = 0; i < len; i++) {
! 		sprintf(pbuffer, "%x", rpath[i]);
! 		pbuffer += 2;
! 	    }
!             LOGW("DroidBox: { \"FdAccess\": { \"path\": \"%s\", \"id\": \"%d\" } }", buffer, id);
!         }
      }
!     RETURN_INT(output);
  }
  
  /*
***************
*** 657,663 ****
  {
      int fd = (int) args[0];
  
!     LOGW("TaintLog: logPeerFromFd not yet implemented");
  
      RETURN_VOID();
  }
--- 668,674 ----
  {
      int fd = (int) args[0];
  
!     LOGW("DroidBox: logPeerFromFd not yet implemented");
  
      RETURN_VOID();
  }
***************
*** 739,745 ****
          Dalvik_dalvik_system_Taint_addTaintFile},
      { "log",  "(Ljava/lang/String;)V",
          Dalvik_dalvik_system_Taint_log},
!     { "logPathFromFd",  "(I)V",
          Dalvik_dalvik_system_Taint_logPathFromFd},
      { "logPeerFromFd",  "(I)V",
          Dalvik_dalvik_system_Taint_logPeerFromFd},
--- 750,756 ----
          Dalvik_dalvik_system_Taint_addTaintFile},
      { "log",  "(Ljava/lang/String;)V",
          Dalvik_dalvik_system_Taint_log},
!     { "logPathFromFd",  "(II)I",
          Dalvik_dalvik_system_Taint_logPathFromFd},
      { "logPeerFromFd",  "(I)V",
          Dalvik_dalvik_system_Taint_logPeerFromFd},
